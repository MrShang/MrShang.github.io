<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favico.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16X16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: true,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="缓存穿透高并发下查询一个值，缓存中没有，数据库中也没有，布隆过滤器 解决方案：  如果数据库中值为空，把空写入缓存即可。  也可以把所有的可能存在的key放入到一个大的Bitmap中，查询时通过该Bitmap过滤   缓存雪崩缓存中大量数据同时到期，高并发下，所有请求都走向数据库 解决方案： 尽量不要把所有缓存都设置在同一时间过期, 通过加锁或者队列只允许一个线程查询数据库和写缓存, 其他线程等待">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://yoursite.com/2020/01/20/redis/index.html">
<meta property="og:site_name" content="Architect">
<meta property="og:description" content="缓存穿透高并发下查询一个值，缓存中没有，数据库中也没有，布隆过滤器 解决方案：  如果数据库中值为空，把空写入缓存即可。  也可以把所有的可能存在的key放入到一个大的Bitmap中，查询时通过该Bitmap过滤   缓存雪崩缓存中大量数据同时到期，高并发下，所有请求都走向数据库 解决方案： 尽量不要把所有缓存都设置在同一时间过期, 通过加锁或者队列只允许一个线程查询数据库和写缓存, 其他线程等待">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-20T07:04:45.000Z">
<meta property="article:modified_time" content="2020-03-09T07:45:57.622Z">
<meta property="article:author" content="Chris Shang">
<meta property="article:tag" content="Redis, 分布式, 缓存">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/01/20/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>redis | Architect</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Architect" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Architect</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">The steps you take don't need to be big. They just need to take you in the right direction.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chris Shang">
      <meta itemprop="description" content="Java, Architect">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Architect">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          redis
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 15:04:45" itemprop="dateCreated datePublished" datetime="2020-01-20T15:04:45+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-09 15:45:57" itemprop="dateModified" datetime="2020-03-09T15:45:57+08:00">2020-03-09</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>高并发下查询一个值，缓存中没有，数据库中也没有，布隆过滤器</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>如果数据库中值为空，把空写入缓存即可。</p>
</li>
<li><p>也可以把所有的可能存在的key放入到一个大的Bitmap中，查询时通过该Bitmap过滤</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存中大量数据同时到期，高并发下，所有请求都走向数据库</p>
<p><strong>解决方案：</strong></p>
<p>尽量不要把所有缓存都设置在同一时间过期, 通过加锁或者队列只允许一个线程查询数据库和写缓存, 其他线程等待.</p>
<p>通过加锁或者队列只允许一个线程查询数据库和写缓存，其他线程等待。</p>
<h2 id="热点缓存（缓存击穿）"><a href="#热点缓存（缓存击穿）" class="headerlink" title="热点缓存（缓存击穿）"></a>热点缓存（缓存击穿）</h2><p>双重检测锁解决热点缓存问题，需要加volatile防止指令重排</p>
<p>高并发下，一个热点缓存到期，然后去数据库中去取，当还没有放入缓存中时，大量请求过来</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>双重检测锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer count = redis.get(<span class="string">"key"</span>);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> &#123;</span><br><span class="line">    count = redis.get(<span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">      count = repo.getCount();</span><br><span class="line">      redis.put(<span class="string">"key"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>也可以用redis的setnx互斥锁进行判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.setnx(lockKey, requestId, NX, PX) == <span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="缓存双写一致性"><a href="#缓存双写一致性" class="headerlink" title="缓存双写一致性"></a><strong>缓存双写一致性</strong></h2><p><strong>解决方案：</strong></p>
<p>延时双删策略, 先更新数据库，再删缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">  redis.delKey(key);</span><br><span class="line">  db.updateData(data);</span><br><span class="line">  <span class="comment">// 可以将以下两步作为异步处理</span></span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a><strong>Redis简介</strong></h2><p>Redis是一种用C语言开发的，高性能的，键值对key-value形式的<strong>noSql</strong>数据库</p>
<p>支持5种<strong>string</strong>, <strong>hash</strong>, <strong>set</strong>, <strong>list</strong>, 有序集合类型(<strong>sortedset</strong>, 简称zset)等数据类型</p>
<p>劣势就是存储的数据缺少结构化</p>
<p>应用场景：</p>
<ul>
<li><p>内存数据库（登录信息，购物车信息，用户浏览记录）</p>
</li>
<li><p>缓存信息</p>
</li>
<li><p>解决分布式架构中的session分离问题</p>
</li>
</ul>
<h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a><strong>redis常用命令</strong></h2><ul>
<li><p>redis-server</p>
</li>
<li><p>redis-client</p>
</li>
<li><p>性能测试工具</p>
<p>redis-benchmark</p>
<p>redis-benchmark -q(Quiet. Just show query/sec values) -n(default 100000 requests)</p>
<p>-h <hostname>      Server hostname (default 127.0.0.1)</hostname></p>
<p> -p <port>          Server port (default 6379)</port></p>
<p> -s <socket>        Server socket (overrides host and port)</socket></p>
<p> -a <password>      Password for Redis Auth</password></p>
<p> -c <clients>       Number of parallel connections (default 50)</clients></p>
<p> -n <requests>      Total number of requests (default 100000)</requests></p>
<p> -d <size>          Data size of SET/GET value in bytes (default 2)</size></p>
<p> -dbnum <db>        SELECT the specified db number (default 0)</db></p>
<p> -k <boolean>       1=keep alive 0=reconnect (default 1)</boolean></p>
<p> -r <keyspacelen>   Use random keys for SET/GET/INCR, random values for SADD</keyspacelen></p>
<p>  Using this option the benchmark will expand the string <strong>rand_int</strong></p>
<p>  inside an argument with a 12 digits number in the specified range</p>
<p>  from 0 to keyspacelen-1. The substitution changes every time a command</p>
<p>  is executed. Default tests use this to hit random keys in the</p>
<p>  specified range.</p>
<p> -P <numreq>        Pipeline <numreq> requests. Default 1 (no pipeline).</numreq></numreq></p>
<p> -q                 Quiet. Just show query/sec values</p>
<p> –csv              Output in CSV format</p>
<p> -l                 Loop. Run the tests forever</p>
<p> -t <tests>         Only run the comma separated list of tests. The test</tests></p>
<p>​                    names are the same as the ones produced as output.</p>
<p> -I                 Idle mode. Just open N idle connections and wait.</p>
</li>
<li><p>redis-check-aof</p>
<p>aof文件检查的工具</p>
</li>
<li><p>redis-check-dump</p>
<p>rdb文件进行检查的工具</p>
</li>
<li><p>redis-sentinel</p>
<p>启动哨兵监控服务</p>
</li>
</ul>
<h2 id="redis数据类型及常用操作"><a href="#redis数据类型及常用操作" class="headerlink" title="redis数据类型及常用操作"></a>redis数据类型及常用操作</h2><ul>
<li><p><strong>string</strong></p>
<p>set key value, get key, getset key value, incr key(必须为整数), incrby key increment, decr key, decrby increment</p>
<p>setnx key value, append key value, strlen key, mset key1 value2 key2 value2…, <strong>mget</strong> key1, key2 …</p>
</li>
<li><p><strong>hash</strong>散列类型，如(people –&gt; name –&gt; “chris”)</p>
<p>字段的名只能用string</p>
<p>hset key field value, hget key field, hmset …, hsetnx key field value(同hset,但是如果field存在，则不执行任何操作),</p>
<p>hmget 批量取, hdel key, hincrby key field increment, hexists key field, hkeys key, hvals key, hlen key, hgetall key</p>
</li>
<li><p><strong>list</strong>类型(链表实现的)</p>
<p>lpush/rpush, lrange, lpop/rpop, llen, </p>
<p>lrem key count value</p>
<p>当count&gt;0时，从左边开始删，删除在count范围内，值为value的元素</p>
<p>当count&lt;0时，从右边开始删</p>
<p>当count=0时，删除所有值为value的元素</p>
<p>lindex, lset key index value, ltrip key start stop, linsert key before|after “specified value” value, rpoplpush,</p>
</li>
<li><p><strong>set</strong>类型</p>
<p>不重复且没有顺序(指放入和取出的顺序不一致)</p>
<p>sadd,srem key value, smembers key, sismember key value, sdiff A B(A - B), sinter A B(A ∩ B), sunion A B(A ∪ B),</p>
<p>scard key(获取元素个数),spop(从集合中随机选择一个元素弹出)</p>
</li>
<li><p><strong>zset</strong>类型（为每个元素都关联一个分数）</p>
<p>有序集合和list对比</p>
<p>相同点：两者都有序，两者都可以获得某一范围内的元素</p>
<p>区别：列表访问两边数据很快，访问中间数据很慢。有序集合都很快</p>
<p>有序列表可以调整元素位置，通过分数实现；</p>
<p>有序集合耗内存</p>
<p>zadd key score member, zrange/zrevrange key start stop [withscores],</p>
<p>zscore key,zrem, zrangebyscore key min max, zincrby key increment member, zcard key(当前集合中元素数量)</p>
<p>zcount key min max(指定分数范围内元素的个数), zremrangebyrank key start stop, zrank/zrevrank key member</p>
</li>
</ul>
<ul>
<li><p>通用命令</p>
<p>keys, del, exists, expire key, ttl key(剩余生存时间), persist key(清除生存时间), </p>
<p>pexpire key milliseconds(生存时间设置单位为毫秒), rname oldkey newkey, type key, </p>
</li>
</ul>
<h2 id="redis事务介绍-指一组命令的集合"><a href="#redis事务介绍-指一组命令的集合" class="headerlink" title="redis事务介绍(指一组命令的集合)"></a>redis事务介绍(指一组命令的集合)</h2><p>redis使用<strong>multi</strong>, <strong>exec</strong>, <strong>discard</strong>, <strong>watch</strong>, <strong>unwatch</strong>实现事务</p>
<p>redis不支持事务回滚</p>
<p>执行multi后，Redis会将命令逐个放入队列中，然后用exce执行这个队列中的命令</p>
<p>而watch是在multi之前，watch某个属性，表示我这个multi块中可能要修改该属性，如果multi块中的命令在未执行前有客户端修改了该请求，那么该multi块中的命令就会执行失败。</p>
<h2 id="redis持久化（指的是持久化到磁盘）"><a href="#redis持久化（指的是持久化到磁盘）" class="headerlink" title="redis持久化（指的是持久化到磁盘）"></a><strong>redis持久化</strong>（指的是<strong>持久化到磁盘</strong>）</h2><p>redis持久化的方式有两种，<strong>RDB</strong>和<strong>AOF</strong></p>
<h3 id="RDB-redis默认方式"><a href="#RDB-redis默认方式" class="headerlink" title="RDB(redis默认方式)"></a>RDB(redis默认方式)</h3><p>rdb是使用快照(snapshotting)的方式进行持久化的</p>
<h4 id="触发快照的时机"><a href="#触发快照的时机" class="headerlink" title="触发快照的时机"></a><strong>触发快照的时机</strong></h4><ul>
<li><p>符合自定义的快照规则</p>
</li>
<li><p>执行save或者bgsave命令</p>
<p><strong>注:</strong> save命令是阻塞的，执行bgsave时会fork出一个进程进行保存，非阻塞的</p>
</li>
<li><p>执行flushall命令</p>
<p><strong>注：</strong>线上一般要禁止掉flushall(删除所有数据库的所有 key),flushdb(删除当前数据库的所有key), keys *等命令</p>
<p>在redis配置文件中添加：</p>
<p>rename-command FLUSHALL “”  </p>
<p>rename-command FLUSHDB “”  </p>
<p>rename-command KEYS “”</p>
</li>
<li><p>执行主从复制操作</p>
</li>
</ul>
<p>redis获取所有数据库：</p>
<p>config get databases(默认有16个数据库，index从0开始)</p>
<p>select 0选择数据库</p>
<h4 id="快照规则-或的关系"><a href="#快照规则-或的关系" class="headerlink" title="快照规则(或的关系)"></a>快照规则(或的关系)</h4><p><strong>save 900 1</strong> <strong>“**</strong>15分钟内有1次修改就进行快照<strong>**”</strong></p>
<p><strong>save 300 10</strong> <strong>“**</strong>5分钟内有10次修改就进行快照<strong>**”</strong></p>
<p><strong>save 60 10000</strong> <strong>“**</strong>1分钟内有10000次修改就进行快照<strong>**”</strong></p>
<p>dir ./ 指定快照地址(rdb文件地址)</p>
<p>dbfilename dump.rdb</p>
<h4 id="快照过程"><a href="#快照过程" class="headerlink" title="快照过程"></a>快照过程</h4><ol>
<li><p><strong>Redis调用系统fork函数复制出一份当前进程的副本(子进程)</strong></p>
</li>
<li><p><strong>子进程开始将内存中的数据写入到硬盘中的临时文件</strong></p>
</li>
<li><p><strong>用临时文件替代旧的rdb文件(经过压缩的二进制文件)</strong></p>
</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p>缺点: 一旦Redis异常退出，就将丢失最后一次快照后更改的所有数据</p>
</li>
<li><p>优点: rdb可以最大化Redis的性能</p>
</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF: 每执行一条更改，Redis就会将该命令写入AOF文件. 实际上是<strong>先写入到硬盘缓存，然后通过硬盘缓存刷新机制保存到文件。</strong></p>
<p><strong>appendfsync always</strong></p>
<p><strong>appendfsync everysec(默认)</strong></p>
<p><strong>appendfsync no(由系统进行sync)</strong></p>
<p>默认关闭，打开是appendonly yes</p>
<p>在数据量比较大的时候，频繁的写入和修改，aof文件会变得非常臃肿，所以我们可以设置重写规则：</p>
<ul>
<li><p>auto-aof-rewrite-min-size：64m</p>
</li>
<li><p>auto-aof-rewrite-percentage：100</p>
</li>
</ul>
<h3 id="RDB-和-AOF比较"><a href="#RDB-和-AOF比较" class="headerlink" title="RDB 和 AOF比较"></a>RDB 和 AOF比较</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是<strong>fork一个子进程</strong>，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<h3 id="数据库备份和灾难恢复"><a href="#数据库备份和灾难恢复" class="headerlink" title="数据库备份和灾难恢复"></a>数据库备份和灾难恢复</h3><p>定时生成RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
<p>Redis 支持同时开启 RDB 和 AOF,系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</p>
<h3 id="RDB-和-AOF-我应该用哪一个"><a href="#RDB-和-AOF-我应该用哪一个" class="headerlink" title="RDB 和 AOF ,我应该用哪一个"></a>RDB 和 AOF ,我应该用哪一个</h3><p>如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久。</p>
<p>AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低 Redis 的性能，不知道你是否可以接受。</p>
<h2 id="redis主从复制"><a href="#redis主从复制" class="headerlink" title="redis主从复制"></a>redis主从复制</h2><ul>
<li><p>只需要在从服务器的配置文件中添加：</p>
<p>slaveof 192.168.1.123 6379</p>
</li>
<li><p>主从复制保证了即使有服务器宕机，也能保证对外提供服务。</p>
</li>
<li><p>当进行主从复制时，不会阻塞。</p>
</li>
<li><p>一个从服务器也可能是另一台服务器的主</p>
</li>
</ul>
<p>原理：</p>
<p><strong>分为全量同步和增量同步</strong></p>
<ul>
<li><strong>全量同步</strong>是当第一次从服务器连接上主服务器时进行的同步，在全量同步期间，主服务器还会有新的写操作过来，这时候主服务器会把这些操作放入到缓冲区。<ol>
<li>master创建快照并发送给slave(将此期间的写入放入缓冲区)</li>
<li>master向slave同步缓冲区的写操作命令</li>
<li>同步增量阶段</li>
</ol>
</li>
</ul>
<ul>
<li><p>增量同步是全量同步之后的一个正常操作的过程</p>
<p>master每执行一个写操作，都会将该命令发送到slave</p>
</li>
</ul>
<h2 id="redis哨兵机制"><a href="#redis哨兵机制" class="headerlink" title="redis哨兵机制"></a>redis哨兵机制</h2><ul>
<li><p>redis主从复制的缺点是当有Redis主服务器进行宕机时，不能进行动态的选举。需要<strong>使用Sentinel机制完成动态选举</strong>。</p>
</li>
<li><p>因此Sentinel进程的作用：监控master的状态（实际上也可以监控slave），在master宕机之后完成动态的选举。</p>
</li>
<li><p>如果有master或者slave宕机，可以通过脚本向管理员发送通知（短信或邮件）。即Monitoring 和 Notification.</p>
</li>
</ul>
<ul>
<li><p><strong>sentinel动态选举过程</strong>（Automatic failover）：</p>
<ol>
<li><p><strong>检测到master出现异常</strong></p>
</li>
<li><p><strong>将其中一个slave复制为新的master</strong></p>
</li>
<li><p><strong>当有slave请求master时</strong></p>
</li>
<li><p><strong>返回新的master地址</strong></p>
</li>
</ol>
<p><strong>注:</strong> master和slave的redis.conf，和sentinel.conf都会发生变化， </p>
</li>
<li><p><strong>sentinel故障分析过程</strong></p>
<ol>
<li>sentinel会以<strong>每秒1次的频率</strong>发送ping命令到Master, Slave 和 其他Sentinel</li>
<li>若回复ping命令超时（sentinel.conf文件中指定的down-after-milliseconds）,则该实例会被标记为<strong>SDOWN</strong>(主管下线)</li>
<li>如果有足够数量(sentinel.conf中指定的)的Sentinel都将该实例标记为SDOWN，则该实例变为<strong>ODOWN</strong></li>
</ol>
</li>
<li><p>监控的主机名称为master，地址和IP，当有2个quorum认为mymaster失联时，则标记为ODOWN</p>
<p>sentinel monitor mymaster 127.0.0.1 6379 2</p>
<p>注意：</p>
<ol>
<li><p>虽然没有写监控slave，但是slave是被自动检测的</p>
</li>
<li><p>虽然指定了ODOWN的数量，但是还是需要大多数的Sentinel同意来开启故障转移</p>
</li>
</ol>
</li>
</ul>
<h2 id="sentinel一些配置"><a href="#sentinel一些配置" class="headerlink" title="sentinel一些配置"></a>sentinel一些配置</h2><ul>
<li><p>port 26379(default)</p>
</li>
<li><p>dir /tmp(工作目录)</p>
</li>
<li><p>当实例开启了requirepass foobared,需要在sentinel.conf中添加如下配置</p>
<ul>
<li><p>sentinel auth-pass <master-name> <password></password></master-name></p>
</li>
<li><p>sentinel down-after-milliseconds <master-name> <milliseconds></milliseconds></master-name></p>
</li>
<li><p>sentinel parallel-syncs <master-name> <numreplicas> 当master发生故障时，最多有几个slave同时对master进行更新</numreplicas></master-name></p>
</li>
</ul>
</li>
<li><p>sentinel failover-timeout mymaster 180000（这个超时时间有4种用途）</p>
<ul>
<li><p>所有slave对新的master进行更新时所需的最大时间，如果超过这个时间，则parallel-syncs无效，变为一次只能有一个更新</p>
</li>
<li><p>同一个Sentinel对同一个master两次failover之间的间隔时间</p>
</li>
<li><p>取消一个正在failover的实例所允许的最大时间(取消的前提是配置文件还未发生变化)</p>
</li>
<li><p>slave从一个错误的master同步数据到纠正为从正确的master同步数据所需要的最大时间</p>
</li>
</ul>
</li>
<li><p>脚本</p>
<ul>
<li><p>脚本返回1，则会重试，默认重试10次</p>
</li>
<li><p>脚本返回值 &gt; 2,不重试</p>
</li>
<li><p>脚本执行中中断，则和返回1效果一样</p>
</li>
<li><p>当一个脚本执行超过60秒，则会被一个SIGKILL信号终止，然后重试</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>通知型脚本</p>
<p>sentinel notification-script mymaster /var/redis/notify.sh</p>
<p>当系统有sdown或者ODOWN时会向管理员发送短信或邮件，该通知接收两个参数，事件类型和事件描述</p>
<p>注：如果配置了该脚本，那么该脚本必须存在且是可执行的，否则无法启动Sentinel</p>
</li>
<li><p>客户端重新配置主节点参数脚本</p>
<p>sentinel client-reconfig-script <master-name> <script-path></script-path></master-name></p>
<p>当master发生改变，执行该脚本通知客户端主机的新地</p>
<p>这些参数将会被传递到该脚本：</p>
<p><master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port></to-port></to-ip></from-port></from-ip></state></role></master-name></p>
<p>state 一直是 failover</p>
<p>role 是 observer或者leader</p>
<p>from-:老的master的IP和端口号，to-:新的master的IP和端口号</p>
</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><h3 id="redis-集群保证了高可用"><a href="#redis-集群保证了高可用" class="headerlink" title="redis 集群保证了高可用"></a><strong>redis 集群保证了高可用</strong></h3><ul>
<li><p>Redis集群特点</p>
<p><strong>集群中的各个实例（节点）彼此互联，通过ping-pong机制</strong></p>
<ul>
<li><strong>节点失效判断(fail):</strong> <strong>需要集群中所有的master投票, 经过半数以上的节点检测失效时才生效</strong></li>
</ul>
</li>
<li><p>客户端与Redis节点是直连，不需要经过任何代理</p>
</li>
<li><p>Redis-cluster把所有物理节点映射到[0-16383]slot上，cluster负责维护node – slot – value</p>
<p>注：redis集群内置了<strong>16384</strong>个slot，当客户端保存一个key-value时，redis先对key使用<strong>crc16</strong>算法算出一个结果，然后把结果对16384取余，Redis会把16384个slot均等的分配到各个节点上。每个节点都包含了一个各个node的信息</p>
</li>
<li><p><strong>集群失效判断</strong></p>
<ul>
<li><p>如果集群任意master挂掉，且该master没有slave时。集群挂掉。因为16384个hash槽不完整</p>
</li>
<li><p>集群超过半数的master挂掉，不管是否有slave。</p>
</li>
</ul>
</li>
<li><p><strong><font color="#dd0000">注: 为什么是16384个槽?</font></strong></p>
<p><strong>(自我描述: redis对一个key进行crc16算法, 产生一个16位(bit)的hash值, 那么该算法可以产生65536个值, 但为什么不是65536个槽, 而是16384个槽呢? 原因有几点:</strong> </p>
<p><strong>1.</strong> <strong>与Redis的心跳机制有关, redis两个节点在发生心跳的时候, 消息头中包含如myslots[CLUSTER_SLOTS/8], 所以如果发送65536个这样的信息, 就需要65536 * 8 * 1024 = 8K, 太大, 浪费带宽;</strong> </p>
<p><strong>2.</strong> <strong>实际16384个槽已经足够用, 因为当redis的节点超过1000时, 整个集群的效率会非常低, 会造成网络拥堵. 因此作者建议不要超过1000个节点)</strong></p>
</li>
</ul>
<h3 id="客户端连接集群"><a href="#客户端连接集群" class="headerlink" title="客户端连接集群"></a>客户端连接集群</h3><ul>
<li><p>./redis-cli -h 127.0.0.1 -p 7001 -c</p>
</li>
<li><p>添加新的节点：</p>
<p>./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001</p>
<p>./redis-trib.rb reshard 127.0.0.1:7001(连接上任一节点即可)</p>
<p>./redis-trib.rb add-node –slave –master-id 主节点id 新节点的IP和端口 旧节点ip和端口（集群中任一节点都可以）</p>
</li>
</ul>
<h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h2><ul>
<li><p>单应用</p>
<p>一般用synchronize，ReentrantLock实现锁</p>
</li>
<li><p>分布式</p>
<p>分布式锁注意事项：</p>
<ul>
<li><p>互斥性：即在任一时刻只有一个客户端能持有锁</p>
</li>
<li><p>同一性：加锁和解锁必须是同一客户端</p>
</li>
<li><p>可重入性：即使一个客户端没有主动解锁（崩溃等），也能保证后续其他客户端能加锁（超时时间）</p>
</li>
</ul>
</li>
<li><p>基于<strong>数据库的乐观锁</strong>实现分布式锁</p>
</li>
<li><p>zookeeper临时节点的分布式锁</p>
</li>
<li><p>基于<strong>Redis的分布式锁</strong></p>
<p>使用set key value [ex seconds] [px milliseconds] [NX|XX]</p>
<p>ex和px都表示过期时间，单位不一样</p>
<p>NX是在不存在时设置，XX是在存在时设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"EX"</span>, expireTime);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>.equals(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>释放锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String requestId, String lockKey)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey)))  &#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="redis-过期策略"><a href="#redis-过期策略" class="headerlink" title="redis 过期策略"></a>redis 过期策略</h2><ul>
<li><p><strong>定期删除</strong>+ <strong>惰性删除</strong> + <strong>内存淘汰机制</strong></p>
<p><strong>定期删除</strong>: Redis默认是每隔100ms就随机抽取一些设置了过期时间的key. 假如redis中有100万个key, 都设置了过期时间,那么肯定不会每隔100毫秒就遍历100万个key然后删除过期了的key. <strong>当get某个key的时候, redis会检测该key有没有过期, 如果过期,就删除, 然后返回空.这就是惰性删除</strong>. 但是内存中如果有10万个key没有被访问到, 不可能让他们长期在内存中消耗内存, 这时候就需要走<strong>内存淘汰机制</strong></p>
<p>内存淘汰机制: </p>
<ul>
<li><p><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧</p>
</li>
<li><p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，<strong>在键空间中</strong>，移除最近最少使用的key（这个是最常用的）</p>
</li>
<li><p><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，<strong>在键空间中</strong>，随机移除某个key，这个一般没人用吧</p>
</li>
<li><p><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，移除最近最少使用的key（这个一般不太合适）</p>
</li>
<li><p><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，随机移除某个key</p>
</li>
<li><p><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，有更早过期时间的key优先移除</p>
</li>
</ul>
</li>
</ul>
<h2 id="redis-cluster对mget的操作"><a href="#redis-cluster对mget的操作" class="headerlink" title="redis cluster对mget的操作"></a><strong>redis cluster对mget</strong>的操作</h2><p>Redis cluster不支持mget操作. 最初是facebook, 2010年使用memcache作缓存, 共有3000个节点. 发现节点太多, 连接频率下降. 继续增加节点, 并没有改善, 是因为IO的成本已经超过数据传输.</p>
<p>所以redis cluster也因此不支持mget操作.redis引入cluster模式后, 是将数据hash到<strong>16384</strong>个slot上, 每个node负责一部分slot.</p>
<p><strong>mget优化方案:</strong> </p>
<ol>
<li><p>n个key, 传统IO, 分别获取, 时间复杂度为O(n)</p>
</li>
<li><p>n个key, 通过Redis的hash算法可以得出各个key所对应的节点, 这样时间复杂度就位O(node.size())</p>
</li>
<li><p>在B方案的基础之上并发处理</p>
</li>
</ol>
<h2 id="redis的redlock"><a href="#redis的redlock" class="headerlink" title="redis的redlock"></a>redis的redlock</h2><ul>
<li><p><strong>redlock的前提是有N个redis的master, 这些节点之间没有主从复制, 或者其他集群协调机制.</strong></p>
</li>
<li><p>client从N个节点尝试获取锁, 只要有N/2 + 1个节点获取成功, 那么便获取成功; 如果最终获取失败, 客户端应该在所有的节点上进行解锁. </p>
</li>
<li><p>redlock的出发点是为了解决Redis集群环境下, 出现的分布式锁的问题(client1获取锁, master 宕机, slave变成master, client2获取到锁). 但是redlock的出现并没有解决这样的问题.</p>
</li>
</ul>
<p><strong><font color="#dd0000">Martin和Redis作者antirez之间的争辩:</font></strong></p>
<p>martin挑了两个缺点:</p>
<p>​    1. 对于提升效率的场景, redlock太重</p>
<p>​    2. 对于正确性要求极高的场景, redlock并不能保证正确性;</p>
<p><strong>问题:</strong> 在client1获取锁之后, 由于某种原因发生<strong>系统停顿</strong>, 锁过期, 然后client1执行操作; client2这时候也会拿到锁, 就会出现问题)</p>
<p><strong>问题:</strong> A, B, C, D, E 5个redis节点,如果C的时间走得快, client1拿到锁(A, B, C), C节点先过期, client2又拿到了(C, D, E)这样就出问题了;</p>
<p>所以Redis从根本上来说是AP, 而分布式锁是要求CP的.</p>
<h2 id="redis各种数据类型的数据结构"><a href="#redis各种数据类型的数据结构" class="headerlink" title="redis各种数据类型的数据结构"></a>redis各种数据类型的数据结构</h2><h3 id="Redis的底层数据结构"><a href="#Redis的底层数据结构" class="headerlink" title="Redis的底层数据结构"></a>Redis的底层数据结构</h3><ul>
<li>简单动态字符串sds(Simple Dynamic String)</li>
<li>双端链表(LinkedList)</li>
<li>字典(Map)</li>
<li>跳跃表(SkipList)</li>
</ul>
<h3 id="redis各种数据类型使用的数据结构"><a href="#redis各种数据类型使用的数据结构" class="headerlink" title="redis各种数据类型使用的数据结构"></a>redis各种数据类型使用的数据结构</h3><ul>
<li><strong>String</strong>, <strong>SDS</strong>(simple dynamic string) 简单动态字符串, 包含len(字符串长度), free(空闲的字节数量), buf(字节数组,存储数据)</li>
<li><strong>List</strong>, 使用<strong>压缩列表</strong>(数据集比较少的时候, 列表中单个数据小于64字节或者列表中数据个数少于512个)和<strong>双向循环链表</strong>, 包含pre, next, value</li>
<li><strong>hash</strong>, 使用<strong>压缩列表</strong>(键和值的大小小于64字节, 列表中键值对个数小于512个)和<strong>散列表</strong></li>
<li><strong>Set</strong>, <strong>有序数组</strong>(个数不超过512)和<strong>散列表</strong></li>
<li><strong>Zset</strong>, <strong>压缩列表</strong>(数据小于64字节或者个数小于128个)和<strong>跳跃表</strong></li>
</ul>
<h3 id="用ziplist代替key-value减少80-内存占用的案例"><a href="#用ziplist代替key-value减少80-内存占用的案例" class="headerlink" title="用ziplist代替key-value减少80%内存占用的案例"></a>用ziplist代替key-value减少80%内存占用的案例</h3><p>​    <strong>背景:</strong> 因业务原因, 需要大量存储key-value数据, key和value都为string, 如果存储1千万条数据，占用了redis共计1.17G的内存. 当数据量变成1个亿时，实测大约占用8个G. 但是修改为key(int), value 为ziplist时, 内存占用为123M, 减少了85%.</p>
<p>​    <strong>步骤:</strong></p>
<ol>
<li><p>要将1千万个键值对, 放到N个bucket中, 但是为了防止ziplist变为hashtable, 每个bucket不能超过512个键值对, 1千万 / 512 = 19531. 将所有key hash到所有bucket中, 但由于hash函数的不确定性, 可能出现不均等分配, 可以分配25000个bucket, 或者30000个bucket.</p>
</li>
<li><p>选用hash算法, 决定将key放到哪个bucket. 这里我们采用高效而且均衡的知名算法crc32. 通过获取原有md5(key)的crc32后, 再对bucket的数量进行取余.</p>
</li>
<li><p>第2步确定了外层的key, 内部的field我们选用bkdr哈希算法.</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> seed = <span class="number">131</span>;</span><br><span class="line">  <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    hash = (hash * seed) + str.charAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (hash &amp; <span class="number">0X7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p>装入1000万条数据, 内存降低了85%; </p>
<p>查询测试, 查100万条数据, 对比查询速度:</p>
<p> key-value耗时：10653、10790、11318、9900、11270、11029毫秒</p>
<p> hash-field耗时：12042、11349、11126、11355、11168毫秒</p>
</li>
</ol>
<h2 id="持续更新-注"><a href="#持续更新-注" class="headerlink" title="持续更新(注)"></a>持续更新(注)</h2><p>该篇blog并不代表该知识点的所有内容, 在今后的工作学习中, <strong><font color="#dd0000">持续更新</font></strong>! 如对blog中的观点有异议/建议,请发送email至: <span class="exturl" data-url="bWFpbHRvOnNoY2hhb3NodWFpQGZveG1haWwuY29t" title="mailto:shchaoshuai@foxmail.com">shchaoshuai@foxmail.com<i class="fa fa-external-link"></i></span>, 感谢您的阅读.</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>Thanks for your donating.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Chris Shang WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Chris Shang Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis-%E5%88%86%E5%B8%83%E5%BC%8F-%E7%BC%93%E5%AD%98/" rel="tag"># Redis, 分布式, 缓存</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/19/kafka/" rel="prev" title="kafka">
      <i class="fa fa-chevron-left"></i> kafka
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/20/spring-cloud/" rel="next" title="spring cloud">
      spring cloud <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存穿透"><span class="nav-number">1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">2.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#热点缓存（缓存击穿）"><span class="nav-number">3.</span> <span class="nav-text">热点缓存（缓存击穿）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存双写一致性"><span class="nav-number">4.</span> <span class="nav-text">缓存双写一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis简介"><span class="nav-number">5.</span> <span class="nav-text">Redis简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis常用命令"><span class="nav-number">6.</span> <span class="nav-text">redis常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis数据类型及常用操作"><span class="nav-number">7.</span> <span class="nav-text">redis数据类型及常用操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis事务介绍-指一组命令的集合"><span class="nav-number">8.</span> <span class="nav-text">redis事务介绍(指一组命令的集合)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis持久化（指的是持久化到磁盘）"><span class="nav-number">9.</span> <span class="nav-text">redis持久化（指的是持久化到磁盘）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-redis默认方式"><span class="nav-number">9.1.</span> <span class="nav-text">RDB(redis默认方式)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#触发快照的时机"><span class="nav-number">9.1.1.</span> <span class="nav-text">触发快照的时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快照规则-或的关系"><span class="nav-number">9.1.2.</span> <span class="nav-text">快照规则(或的关系)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快照过程"><span class="nav-number">9.1.3.</span> <span class="nav-text">快照过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点"><span class="nav-number">9.1.4.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">9.2.</span> <span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-和-AOF比较"><span class="nav-number">9.3.</span> <span class="nav-text">RDB 和 AOF比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库备份和灾难恢复"><span class="nav-number">9.4.</span> <span class="nav-text">数据库备份和灾难恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-和-AOF-我应该用哪一个"><span class="nav-number">9.5.</span> <span class="nav-text">RDB 和 AOF ,我应该用哪一个</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis主从复制"><span class="nav-number">10.</span> <span class="nav-text">redis主从复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis哨兵机制"><span class="nav-number">11.</span> <span class="nav-text">redis哨兵机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sentinel一些配置"><span class="nav-number">12.</span> <span class="nav-text">sentinel一些配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-集群"><span class="nav-number">13.</span> <span class="nav-text">Redis 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-集群保证了高可用"><span class="nav-number">13.1.</span> <span class="nav-text">redis 集群保证了高可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端连接集群"><span class="nav-number">13.2.</span> <span class="nav-text">客户端连接集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis实现分布式锁"><span class="nav-number">14.</span> <span class="nav-text">redis实现分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-过期策略"><span class="nav-number">15.</span> <span class="nav-text">redis 过期策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-cluster对mget的操作"><span class="nav-number">16.</span> <span class="nav-text">redis cluster对mget的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis的redlock"><span class="nav-number">17.</span> <span class="nav-text">redis的redlock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis各种数据类型的数据结构"><span class="nav-number">18.</span> <span class="nav-text">redis各种数据类型的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的底层数据结构"><span class="nav-number">18.1.</span> <span class="nav-text">Redis的底层数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis各种数据类型使用的数据结构"><span class="nav-number">18.2.</span> <span class="nav-text">redis各种数据类型使用的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用ziplist代替key-value减少80-内存占用的案例"><span class="nav-number">18.3.</span> <span class="nav-text">用ziplist代替key-value减少80%内存占用的案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持续更新-注"><span class="nav-number">19.</span> <span class="nav-text">持续更新(注)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chris Shang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chris Shang</p>
  <div class="site-description" itemprop="description">Java, Architect</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01yU2hhbmc=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MrShang"><i class="fa fa-fw fa-github"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNoY2hhb3NodWFpQGZveGFpbC5jb20=" title="E-Mail → mailto:shchaoshuai@foxail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chris Shang</span>
</div>
  <div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <span class="exturl theme-link" data-url="aHR0cHM6Ly9tdXNlLnRoZW1lLW5leHQub3Jn">NexT.Muse</span> v7.7.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  

</body>
</html>
